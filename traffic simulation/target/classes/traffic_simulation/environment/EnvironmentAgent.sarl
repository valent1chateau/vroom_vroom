/* 
 * $Id$
 * 
 * Copyright (c) 2014-17 Stephane GALLAND <stephane.galland@utbm.fr>.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * This program is free software; you can redistribute it and/or modify
 */
package traffic_simulation.environment

import io.sarl.core.AgentSpawned
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.awt.geom.Point2D
import java.util.ArrayList
import java.util.Random
import java.util.UUID
import java.util.concurrent.atomic.AtomicInteger
import traffic_simulation.^agent.classicDriver
import traffic_simulation.^agent.influence

/*  
 * This agent is managing the physic space.
 */


event Perceptions{
	var p_value : ArrayList<Vehicle>
	var state : double[]
	var loc : Point2D
	var dim : double
	var distwithLight : double 
	var isRedView : boolean
	new (p : ArrayList<Vehicle>,vtm : double,vt : double, am : double,co : Point2D,d : double,isRed : boolean,distLight : double){
	p_value = p
	state = #[vtm,vt,am]
	loc = co
	dim = d
	isRedView = isRed
	distwithLight = distLight
	
	}	
}

event suicide {
}

agent EnvironmentAgent {
	
	uses  Lifecycle, DefaultContextInteractions, Logging, Schedules
	
	var environment : Environment
	
	var dt = 0.5
	var spawnedReceived : AtomicInteger = new AtomicInteger(0)
	var nbrAgentOnMap = 0
	var countAgentInfluence = new AtomicInteger(0)
	var countAgentSpawned = 0
	var nbTotalVehiculeClassic : int
	var accBody : double
			
	on Initialize {
		
		environment = occurrence.parameters.get(0) as Environment
		nbTotalVehiculeClassic = environment.nombreTotalAgentClassic
		accBody = environment.nbAccl
		
		//nbTotalVehicule =  
		/*environment.initEnvironment(10);
		for(entry : environment.bodyList.entrySet()){
			//println(environment.bodyList.get(entry.getKey()))
			typeof(classicDriver).spawnInContextWithID(entry.getKey(),defaultContext)
		}
		 * spawn(typeof(priorityDriver))
		 */
		actionsOnInfluence
	}
	
	on Destroy{
		environment.stop
	}
	
	on AgentSpawned {
		var v : int = spawnedReceived.incrementAndGet
		if (v == countAgentSpawned) {
			
			
			countAgentSpawned = 0
			spawnedReceived = new AtomicInteger(0)
			startLoop()
			
			
		}
	}
	
	on influence{
		
		var ac = occurrence.acc
		var id = occurrence.idt 
		environment.bodyList.get(id).acc = ac
		
		if (countAgentInfluence.incrementAndGet() == nbrAgentOnMap) {
			
			countAgentInfluence.set(0)
			
			actionsOnInfluence()
			
		}
	}
	
	def startLoop {
		
		var bodies = environment.bodyList
		nbrAgentOnMap = environment.bodyList.size()
		
		if (bodies.isEmpty == false) {
			//println(bodies.size)
			for(entry : bodies.entrySet()){
				bodies.get(entry.getKey()).calculatePerceptions
				var p = bodies.get(entry.getKey()).perception.res
				var vmax = bodies.get(entry.getKey()).maxSpeed
				var v = bodies.get(entry.getKey()).speed
				var amax = bodies.get(entry.getKey()).accMax
				var coo = bodies.get(entry.getKey()).coord
				var dims = bodies.get(entry.getKey()).dim
				var redLight = bodies.get(entry.getKey()).perception.getLightIsView
				var dstLight = bodies.get(entry.getKey()).perception.distWithLight
				
				
				
				emit(new Perceptions(p, vmax, v, amax, coo, dims, redLight, dstLight))[it.UUID == entry.getKey()]
			
			
				
				
			}
		
		}
	}
	
	def actionsOnInfluence(){
		
			var listKey : ArrayList<UUID> = new ArrayList<UUID>
			
			
			 
			if(environment.bodyList.isEmpty!=true){
				environment.Update()
				
				for (entry : environment.bodyList.entrySet()) {
					if (environment.bodyList.get(entry.getKey()).position >=
					environment.bodyList.get(entry.getKey()).distanceMax) {
						
					listKey.add(entry.getKey())
					
					
						
					}
				}
				for (var k = 0; k < listKey.size(); k++) {
					environment.bodyList.remove(listKey.get(k))
					var key = listKey.get(k)
					emit(new suicide())[it.UUID == key]
				}
				
			}
		
		var rand = new Random
		var nbAgent = 1 + rand.nextInt(4)
		for (var i = 1; i <= nbAgent; i++) {
			var bodyAgent = new classicDriverBody(this.environment.map, accBody)
			if (bodyAgent.canSpawn == true){
				if (nbTotalVehiculeClassic!=0) {
					bodyAgent.initialzeEdgeBodies
					environment.bodyList.put(bodyAgent.ID, bodyAgent)
					
					typeof(classicDriver).spawnInContextWithID(bodyAgent.ID, defaultContext)
					countAgentSpawned += 1
					nbTotalVehiculeClassic -=1
					} 
				} 
		}
		if (countAgentSpawned == 0){
			Thread::sleep(20)
			if (nbTotalVehiculeClassic == 0 && environment.bodyList.isEmpty) {
				print("e")
				killMe
			}

		
			else {
			startLoop
		}
			
		}
		
		
		
		}
	
	/*def endLoop {
		startLoop();
	}*/
	
//	on Influence { }
// on Perception { }
	
}
