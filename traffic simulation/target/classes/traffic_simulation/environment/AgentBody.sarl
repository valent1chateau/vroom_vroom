/* 
 * $Id$
 * 
 * Copyright (c) 2011-17 Stephane GALLAND <stephane.galland@utbm.fr>.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * This program is free software; you can redistribute it and/or modify
 */
package traffic_simulation.environment
import traffic_simulation.util.Tools
// import traffic_simulation.math.Shape2f
import java.util.ArrayList
import java.util.UUID
// import traffic_simulation.math.Vector2f
// import traffic_simulation.math.MathUtil
import java.util.List
import java.text.MessageFormat
import org.eclipse.xtend.lib.annotations.Accessors
import java.awt.geom.Point2D
import javafx.scene.shape.Circle
import javafx.scene.paint.Color
import java.util.Random

/**
 * Object on the environment.
 * 
 * @author St&eacute;phane GALLAND &lt;stephane.galland@utbm.fr&gt;
 * @version $Name$ $Revision$ $Date$
 */
 
abstract class Vehicle implements Body {
	var tool : Tools = new Tools
	@Accessors
	var id : UUID
	@Accessors
	var c : Circle
	@Accessors
	var coord : Point2D
	@Accessors
	var dim : double

	@Accessors
	var edge : Edge
	@Accessors
	var spawn : Node
	@Accessors
	var pos_edge : double
	@Accessors
	var accMax : double
	@Accessors
	var acc : double
	@Accessors
	var speed : double
	@Accessors
	var maxSpeed : double
	@Accessors
	var position : double
	var distance : double
	@Accessors
	var distanceMax : double
	@Accessors
	var path : Path
	@Accessors
	var perception : Perception
	@Accessors
	var kill : boolean = false
	
	new() {
		id = UUID.randomUUID()
		path = new Path
		position = 0.0
		pos_edge = 0.0
		distance = 0.0
		distanceMax = 0.0
		speed = 0.0
		acc = 0.0
		
	}
	
	def getID(): UUID {
		return this.id
	}
	
	def positionToCoord() {
		
		var e = path.pathEdges
		var j = 0
		var stop = false
		var TotalWeight : double = 0.0
		while (j < e.size() && stop == false) {
			TotalWeight = TotalWeight + e.get(j).weight
			
			if (position == 0){stop = true}
			else if (position <= TotalWeight) {
				//var pos_edge : double 
				var dist_edge : double = 0.0
				if (j>0){
					for (var i = 0; i < j; i++) {
						dist_edge += e.get(i).weight
					}
					
				}
				pos_edge = position - dist_edge
				var percent = pos_edge / e.get(j).weight
				
				var poly = e.get(j).getPoints()
				var nbP = poly.size / 2
				
				var at : int = Math.round(nbP * percent) as int
				//println(a)
				if (at != 0) {
					var ind = 2 * at - 2
					//println(ind)
					var x = poly.get(ind)
					var y = poly.get(ind + 1)
					coord.setLocation(x,y)
					c.setCenterX(x)
					c.setCenterY(y)
				}

				if (e.get(j).id_ != this.edge.id_) {
					
					edge.removeBody(this)
					
					edge = e.get(j)
					edge.addBody(this)
					
					
				}
				
				stop = true
				
			} else if (position > distanceMax) {
				edge.removeBody(this)
				stop = true
				kill = true
			}
			j += 1
		}
	}
	def move(X : double){
		distance = X
		position = position + distance
	}
	
	def abstract newPath(G : Graph)
		
	def D_Max(){
		var res: double = 0.0
		for(var i = 0 ;i<path.pathEdges.size();i++){
			res = res + path.pathEdges.get(i).weight
		}
		distanceMax = res
	}
	
	def accelerate( t : double) {
		if (acc< -2){acc = -2}
		if (speed < maxSpeed){
		
		speed = speed + tool.calc_speed(acc,t)}
		if (speed<0){speed=0}
		//if(speed==0){acc=0}
		this.move(tool.calc_position(speed, t))
		positionToCoord()
		
		//println(acc)
		//println(speed)
		//println(tool.calc_position(speed, t))
	}
	
	//def accelerate(): void {
		
	//}
	
	def canSpawn():boolean{
		var res = true
		var lst_v = edge.bodies
		var sx = spawn.coord.getX()
		var sy = spawn.coord.getY()
		var s_id = spawn.id
		
		lst_v.remove(this)
		if (lst_v.isEmpty != true){
			var i = 0
			while (i<lst_v.size() && res==true){
				if (s_id == 8 ) {
					if (
						sy - this.dim / 2 < lst_v.get(i).coord.getY() + lst_v.get(i).dim / 2) {
						//println(lst_v.get(i).coord.getY() - dim / 2 + " , " + sy + lst_v.get(i).coord.getY() + dim / 2)
						res = false
						}
					} 
				else if(s_id == 18){
					if (sy + this.dim / 2 > lst_v.get(i).coord.getY() - lst_v.get(i).dim / 2) {
						res = false
					}
				}
				else if (s_id == 2 || s_id == 2){
					if(sx + this.dim / 2 > lst_v.get(i).coord.getX() - lst_v.get(i).dim / 2 ){
						res = false
					}
				}
				else{
					if ( 
						sx - this.dim / 2 < lst_v.get(i).coord.getX() + lst_v.get(i).dim / 2 )
			{
						res = false
					}
				}
				i = i + 1
			}
		}
		return res
	}

	def initialzeEdgeBodies() {
		this.edge.addBody(this)	
	}
	def deccelerate(): void {
		
	}
	
	def calculatePerceptions() : void {
		perception.perceptLight()
		perception.percept()
		
		
	}
}

class priorityVehicleBody extends Vehicle {
	
	def newPath(G : Graph) {
		var i:int 
	}
	
}

class classicDriverBody extends Vehicle{
	
	new(map : Map) {
		super()
		newPath(map.getG)
		var x = path.pathNodes.get(0).coord.getX()
		var y = path.pathNodes.get(0).coord.getY()
		coord = new Point2D.Double
		c = new Circle
		coord.setLocation(x, y)
		c.setCenterX(x)
		c.setCenterY(y)
		c.setRadius(2.25)
		dim = 2*2.25
		this.c.setFill(Color.BLUE)
		D_Max()
		
		accMax =4
		maxSpeed = 13.8
		this.perception = new Perception(this, 150.0, map.getG)
		this.edge = path.pathEdges.get(0)
	}
	
	
	
	def newPath(G:Graph) {
		var in : ArrayList<Node> = new ArrayList<Node>
		var out : ArrayList<Node> = new ArrayList<Node>
		for (var i = 0; i < G.getListNodes.size();i = i + 2){
			
			if(i == 0 || i == 6 || i == 10 || i == 16){
				out.add(G.getListNodes.get(i))
			} else {
				in.add(G.getListNodes.get(i))
			}
		}
		var rand : Random = new Random
		var numIN : int = rand.nextInt(in.size())
		var numOUT : int
		
		if (in.get(numIN).id == 2){
			numOUT = 3
		} else if (in.get(numIN).id == 12) {
			numOUT = 1
		}else{
			if (in.get(numIN).id == 4) {
				numOUT = 1 + rand.nextInt(2)
			} else if (in.get(numIN).id == 8) {
				numOUT = 1 + rand.nextInt(3)
				if (numOUT == 1){ numOUT = 0}
			} else if (in.get(numIN).id == 14) {
				numOUT = 2 + rand.nextInt(2)
				if (numOUT==2){numOUT=0}
			} else if (in.get(numIN).id == 18) {
				numOUT =  rand.nextInt(3)
			}
		}
		spawn = in.get(numIN)
		path.Astar(G,in.get(numIN),out.get(numOUT))
	}
	
}