/* 
 * $Id$
 * 
 * Copyright (c) 2014-17 Stephane GALLAND <stephane.galland@utbm.fr>.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * This program is free software; you can redistribute it and/or modify
 */
package traffic_simulation.environment

import traffic_simulation.^agent.*
import traffic_simulation.time.TimePercept
import traffic_simulation.environment.*
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.lang.core.Address
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import io.sarl.core.OpenEventSpace
import io.sarl.core.Logging
import io.sarl.core.AgentSpawned
import java.util.ArrayList
import java.util.TreeMap
import io.sarl.core.Schedules
import java.util.Random
import io.sarl.core.Time
import java.awt.geom.Point2D

/*  
 * This agent is managing the physic space.
 */


event Perceptions{
	var p_value : ArrayList<Vehicle>
	var state : double[]
	var loc : Point2D
	var dim : double
	var distwithLight : double 
	var isRedView : boolean
	new (p : ArrayList<Vehicle>,vtm : double,vt : double, am : double,co : Point2D,d : double,isRed : boolean,distLight : double){
	p_value = p
	state = #[vtm,vt,am]
	loc = co
	dim = d
	isRedView = isRed
	distwithLight = distLight
	
	}	
}

event suicide {
}

agent EnvironmentAgent {
	
	uses  Lifecycle, DefaultContextInteractions, Logging, Schedules
	
	var environment : Environment
	
	var dt = 0.5
	var spawnedReceived : AtomicInteger = new AtomicInteger(0)
	var nbrAgentOnMap = 0
	var countAgentInfluence = new AtomicInteger(0)
	var countAgentSpawned = 0
	var nbTotalVehiculeClassic : int
	
			
	on Initialize {
		
		environment = occurrence.parameters.get(0) as Environment
		nbTotalVehiculeClassic = environment.nombreTotalAgentClassic
		//nbTotalVehicule =  
		/*environment.initEnvironment(10);
		for(entry : environment.bodyList.entrySet()){
			//println(environment.bodyList.get(entry.getKey()))
			typeof(classicDriver).spawnInContextWithID(entry.getKey(),defaultContext)
		}
		 * spawn(typeof(priorityDriver))
		 */
		actionsOnInfluence
	}

	on AgentSpawned {
		var v : int = spawnedReceived.incrementAndGet
		if (v == countAgentSpawned) {
			
			//emit(new light("green"))
			countAgentSpawned = 0
			spawnedReceived = new AtomicInteger(0)
			startLoop()
			// killMe
			
		}
	}
	
	on influence{
		// var u = countAgentInfluence.incrementAndGet
		var ac = occurrence.acc
		var id = occurrence.idt 
		environment.bodyList.get(id).acc = ac
		//println(environment.bodyList.get(id).edge.id_)
		//println(nbrAgentOnMap)
		if (countAgentInfluence.incrementAndGet() == nbrAgentOnMap) {
			// info("oui")
			// println(countAgentInfluence.get())
			countAgentInfluence.set(0)
			//println(countAgentInfluence)
			actionsOnInfluence()
			
		}
	}
	
	def startLoop {
		//Compute perceptions
		var bodies = environment.bodyList
		nbrAgentOnMap = environment.bodyList.size()
		//println(nbrAgentOnMap)
		//println(countAgentSpawned)
		if (bodies.isEmpty == false) {
			//println(bodies.size)
			for(entry : bodies.entrySet()){
				bodies.get(entry.getKey()).calculatePerceptions
				var p = bodies.get(entry.getKey()).perception.res
				var vmax = bodies.get(entry.getKey()).maxSpeed
				var v = bodies.get(entry.getKey()).speed
				var amax = bodies.get(entry.getKey()).accMax
				var coo = bodies.get(entry.getKey()).coord
				var dims = bodies.get(entry.getKey()).dim
				var redLight = bodies.get(entry.getKey()).perception.getLightIsView
				var dstLight = bodies.get(entry.getKey()).perception.distWithLight
				
				
				
				emit(new Perceptions(p, vmax, v, amax, coo, dims, redLight, dstLight))[it.UUID == entry.getKey()]
			
				//Suppression des bodies arrives a destination
				/*if (bodies.get(entry.getKey()).position > bodies.get(entry.getKey()).distanceMax) {
					environment.bodyList.remove(entry.key)
					info("suppression de body enregistrée")
					nbrAgentOnMap = nbrAgentOnMap - 1
					//emit(new suicide())[it.UUID == entry.getKey()]
					
				}*/
				
				
			}
		
		}
	}
	
	def actionsOnInfluence(){
		
			
			
			// println(t)
			 
			if(environment.bodyList.isEmpty!=true){
				environment.Update()

				for (entry : environment.bodyList.entrySet()) {
					if (environment.bodyList.get(entry.getKey()).position >
					environment.bodyList.get(entry.getKey()).distanceMax) {
						
					environment.bodyList.remove(entry.getKey())
						// info("suppression de body enregistrée")
					//nbTotalVehiculeClassic = nbTotalVehiculeClassic - 1
					emit(new suicide())[it.UUID == entry.getKey()]
						
					}
				}
			}
		//Thread::sleep(1)
		var rand = new Random
		var nbAgent = 1 + rand.nextInt(4)
		for (var i = 1; i <= nbAgent; i++) {
			var bodyAgent = new classicDriverBody(this.environment.map)
			if (bodyAgent.canSpawn == true){
				if (environment.bodyList.size < nbTotalVehiculeClassic) {
					// println("z")
					bodyAgent.initialzeEdgeBodies
					environment.bodyList.put(bodyAgent.ID, bodyAgent)
					
					typeof(classicDriver).spawnInContextWithID(bodyAgent.ID, defaultContext)
					countAgentSpawned += 1
					} 
				} 
		}
		if (countAgentSpawned == 0){
			// print("s")
			Thread::sleep(20)
			startLoop
		}
		
		}
		
		
	
	/*def endLoop {
		startLoop();
	}*/
	
//	on Influence { }
// on Perception { }
	
}
